/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

import * as Msdyn365 from '@msdyn365-commerce/core';
import { OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import { IModuleProps, INodeProps } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import { observable, when, reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
// Remove the static import of azure-maps-control
import { ArrayExtensions } from '@msdyn365-commerce-modules/retail-actions';
// Import the types only from azure-maps-control
// eslint-disable-next-line prettier/prettier
import type * as atlas from 'azure-maps-control';

import { IAzureMapsData } from './azure-maps.data';
import { IAzureMapsProps, IPushpinOptionsData } from './azure-maps.props.autogenerated';

/**
 * Header Interface.
 */
export interface IHeader {
    headerProps: INodeProps;
    heading: React.ReactNode;
}

/**
 * AzureMapViewProps Interface.
 */
export interface IAzureMapViewProps extends IAzureMapsProps<IAzureMapsData> {
    ModuleProps?: IModuleProps;
    Header?: IHeader;
    MapProps?: INodeProps;
    Map?: atlas.Map | undefined; // Change from Microsoft.Maps.Map to atlas.Map
}

/**
 * AzureMap component.
 * @extends {React.Component<IAzureMapsProps<IAzureMapsData>>}
 */
@observer
class AzureMap extends React.Component<IAzureMapsProps<IAzureMapsData>> {
    @observable public map: atlas.Map | undefined; // Change from Microsoft.Maps.Map to atlas.Map
    private timeout: number = 500;

    private readonly mapRef: React.RefObject<HTMLElement> = React.createRef<HTMLElement>();

    public constructor(props: IAzureMapsProps<IAzureMapsData>) {
        super(props);
    }

    public componentDidMount(): void {
        this._loadCss();
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: { channel }
                }
            }
        } = this.props;
        // TODO: Check with getOrgUnitConfiguration
        if (channel && !channel.BingMapsApiKey) {
            telemetry.error('AzureMapsApiKey is missing.');
            return;
        }

        if (channel && !channel.BingMapsEnabled) {
            telemetry.error('Map is disabled from HQ.');
            return;
        }
        const loadMapAPIInput = {
            key: channel?.BingMapsApiKey, // channel?.BingMapsApiKey,
            lang: this.props.context.actionContext.requestContext.locale,
            market: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode,
            AzureMapsEnabled: channel?.BingMapsEnabled
        };

        when(
            () => !!this.props.data.storeSelectorStateManager?.result?.setMapModuleLoaded,
            () => {
                this.props.data.storeSelectorStateManager?.result?.setMapModuleLoaded(true);
            }
        );

        when(
            () => !!this.props.data.distributorSelectorStateManager?.result?.setMapModuleLoaded,
            () => {
                this.props.data.distributorSelectorStateManager?.result?.setMapModuleLoaded(true);
            }
        );

        reaction(
            () =>
                this.props.data.storeSelectorStateManager?.result?.loadMapApi ||
                this.props.data.distributorSelectorStateManager?.result?.loadMapApi,
            () => {
                if (this.props.data.distributorSelectorStateManager?.result?.loadMapApi) {
                    this.props.data.distributorSelectorStateManager?.result?.loadMapApi(loadMapAPIInput);
                } else {
                    this.props.data.storeSelectorStateManager?.result?.loadMapApi(loadMapAPIInput);
                }
            }
        );

        import('azure-maps-control')
            .then(atlas => {
                const azureMapsAuthOptions: atlas.AuthenticationOptions = {
                    authType: atlas.AuthenticationType.subscriptionKey,
                    subscriptionKey: channel?.BingMapsApiKey
                };

                if (
                    this.props.data.storeSelectorStateManager?.result?.isMapApiLoaded ||
                    this.props.data.distributorSelectorStateManager?.result?.isMapApiLoaded
                ) {
                    this._initMap(azureMapsAuthOptions, atlas);
                    if (this.props.data.distributorSelectorStateManager?.result?.isDistributorSelectorDialogOpen) {
                        this._updateMapsForDistributor(atlas);
                    } else {
                        this._updateMap(atlas);
                    }
                }

                reaction(
                    () =>
                        this.props.data.storeSelectorStateManager?.result?.isMapApiLoaded ||
                        this.props.data.distributorSelectorStateManager?.result?.isMapApiLoaded,
                    () => {
                        this._initMap(azureMapsAuthOptions, atlas);
                    }
                );

                // this.map = new atlas.Map(this.mapRef.current as HTMLElement, newLocal, atlas);
                reaction(
                    () => {
                        return [
                            this.props.data.storeSelectorStateManager?.result?.context?.orgUnitStoreInformation,
                            this.props.data.storeSelectorStateManager?.result?.selectedStoreLocationId,
                            this.map
                        ];
                    },
                    () => {
                        this._updateMap(atlas);
                    }
                );

                reaction(
                    () => {
                        return [
                            this.props.data.distributorSelectorStateManager?.result?.distributorList,
                            this.props.data.distributorSelectorStateManager?.result?.selectedDistributorId,
                            this.map
                        ];
                    },
                    () => {
                        this._updateMapsForDistributor(atlas);
                    }
                );
            })
            .catch(error => {
                telemetry.error('Error loading azure-maps-control:', error);
                console.error('Error loading azure-maps-control:', error);
            });

    }

    public render(): JSX.Element | null {
        const {
            data: { distributorSelectorStateManager, storeSelectorStateManager },
            config: { heading, className }
        } = this.props;

        const shouldDisplayMap = storeSelectorStateManager?.result?.isDialogOpen
            ? storeSelectorStateManager.result.listMapViewState.displayMap
            : distributorSelectorStateManager?.status === 'SUCCESS' &&
              distributorSelectorStateManager?.result?.isDistributorSelectorDialogOpen
            ? distributorSelectorStateManager.result.listMapViewState.displayMap
            : true;

        const viewProps: IAzureMapViewProps = {
            ...this.props,
            ModuleProps: {
                tag: 'div',
                moduleProps: this.props,
                className: classname('ms-azure-maps', { show: shouldDisplayMap }, className)
            },
            Header: {
                headerProps: { className: 'ms-map__header' },
                heading: heading?.text && (
                    <Msdyn365.Text
                        className='ms-map__heading'
                        {...heading}
                        tag={heading.tag || 'h2'}
                        text={heading.text}
                        editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
                    />
                )
            },
            MapProps: {
                tag: 'div',
                className: 'ms-map__body',
                ref: this.mapRef,
                style: { height: '650px' }
            },
            Map: this.map
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    /**
     * Method to be called on heading change.
     * @param event -Content Edit Event.
     */
    public handleHeadingChange = (event: Msdyn365.ContentEditableEvent): void => {
        this.props.config.heading!.text = event.target.value;
    };

    /**
     * Initialize the map.
     */
    private readonly _initMap = (azureMapsAuthOptions: atlas.AuthenticationOptions, atlas: typeof import('azure-maps-control')) => {
        const { data } = this.props;

        // if (data.storeSelectorStateManager?.result?.isMapApiLoaded || data.distributorSelectorStateManager?.result?.isMapApiLoaded) {
        this.map = new atlas.Map(this.mapRef.current as HTMLElement, azureMapsAuthOptions);
        this.map.events.add('ready', () => {
            this.map?.controls.add(new atlas.control.ZoomControl(), {
                position: atlas.ControlPosition.TopRight
            });
        });
        this.map.events.add('click', async () => {
            if (data.distributorSelectorStateManager?.result?.isDistributorSelectorDialogOpen) {
                data.distributorSelectorStateManager?.result?.updateDistributorMapVisibility(false);
                await data.distributorSelectorStateManager?.result?.setSelectedDistributorId(undefined);
            } else {
                await data.storeSelectorStateManager?.result?.setSelectedStoreLocationId(undefined);
            }
        });
        // }
    };

    private readonly _updateMapsForDistributor = (atlas: typeof import('azure-maps-control')) => {
        const pushpinOptions = this.props.config.pushpinOptions;
        const distributorSelectorStateManager = this.props.data.distributorSelectorStateManager?.result;
        const distributorInfoList = distributorSelectorStateManager?.distributorList;
        const selectedDistributorId = distributorSelectorStateManager?.selectedDistributorId;

        if (this.map && ArrayExtensions.hasElements(distributorInfoList)) {
            let mapLocation: OrgUnitLocation | undefined;
            this.map.markers.clear();

            const distributorList = distributorInfoList.filter(distributor => distributor.OrgUnit !== undefined);

            for (const [index, distributorInfo] of distributorList.entries()) {
                const orgUnit = distributorInfo.OrgUnit;

                if (orgUnit?.Latitude && orgUnit.Longitude) {
                    const isLocationSelected = selectedDistributorId === orgUnit?.RecordId;
                    const options = this._getPushpinOptions(isLocationSelected, index, pushpinOptions);
                    const marker = new atlas.HtmlMarker({
                        position: [orgUnit.Longitude, orgUnit.Latitude],
                        color: isLocationSelected ? 'green' : 'red',
                        options
                    });

                    this.map.markers.add(marker);

                    if (isLocationSelected) {
                        mapLocation = orgUnit;
                    }
                }
            }
            if (mapLocation) {
                this.map.setCamera({ center: [mapLocation.Longitude, mapLocation.Latitude] });
            } else {
                // Get all markers from the map
                const markers = this.map.markers.getMarkers();

                // Extract valid positions
                const positions = markers
                    .map((marker: atlas.HtmlMarker): atlas.data.Position | undefined => marker.getOptions().position) // Extract position
                    .filter((pos: atlas.data.Position | undefined): pos is atlas.data.Position => !!pos); // Remove undefined values

                if (positions.length > 0) {
                    // Create a bounding box from the marker positions
                    const bounds = atlas.data.BoundingBox.fromPositions(positions);

                    // Set the camera to fit the bounding box
                    this.map.setCamera({ bounds: bounds });
                }

            }
        }
    };

    /**
     * Update the map.
     */
    private readonly _updateMap = (atlas: typeof import('azure-maps-control')) => {
        const { pushpinOptions } = this.props.config;
        const storeSelectorStateManager = this.props.data.storeSelectorStateManager?.result;
        const orgUnitStoreInformation = storeSelectorStateManager?.context?.orgUnitStoreInformation;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;

        if (this.map && orgUnitStoreInformation) {
            let mapLocation: OrgUnitLocation | undefined;
            this.map.markers.clear();
            const pushpins: atlas.HtmlMarker[] = [];

            const storeLocationList = orgUnitStoreInformation.filter(store => store.OrgUnitAvailability !== undefined);

            for (const [index, unitStoreInfo] of storeLocationList.entries()) {
                const storeLocation = unitStoreInfo.OrgUnitAvailability?.OrgUnitLocation;

                if (storeLocation?.Latitude && storeLocation.Longitude) {
                    const isSelectedLocation = selectedStoreLocationId === storeLocation.OrgUnitNumber;
                    const markerOptions = this._getPushpinOptions(isSelectedLocation, index, pushpinOptions);

                    const pushpin = new atlas.HtmlMarker({
                        position: [storeLocation.Longitude, storeLocation.Latitude],
                        htmlContent: markerOptions.icon,
                        color: markerOptions.color
                    });

                    this.map.markers.add(pushpin);

                    this.map.events.add('click', pushpin, () => {
                        this.handleClickEvent(storeLocation.OrgUnitNumber);
                    });

                    isSelectedLocation ? pushpins.unshift(pushpin) : pushpins.push(pushpin);

                    if (isSelectedLocation) {
                        mapLocation = storeLocation;
                    }
                }
            }

            if (mapLocation) {
                const currentLocation = [mapLocation.Longitude, mapLocation.Latitude];
                this.map.setCamera({ center: currentLocation, zoom: 14 });
            } else {
                // Auto-fit map to show all pushpins

                // // type predicate
                // const positions = pushpins
                //     .map(pin => pin.getOptions().position)
                //     .filter((pos): pos is atlas.data.Position => pos !== undefined);

                // explicit type assertion
                const positions = pushpins.map(pin => pin.getOptions().position).filter(pos => pos !== undefined) as atlas.data.Position[];

                if (positions.length > 0) {
                    const bounds = atlas.data.BoundingBox.fromPositions(positions);
                    this.map.setCamera({ bounds, padding: 50 });
                }

                // const bounds = atlas.data.BoundingBox.fromData(pushpins.map(pin => pin.getOptions().position));
                // this.map.setCamera({ bounds, padding: 50 });
            }
        }
    };

    private readonly handleClickEvent = (orgUnitNumber: string | undefined): void => {
        const storeSelectorStateManager = this.props.data.storeSelectorStateManager?.result;
        storeSelectorStateManager?.setSelectedStoreLocationId(undefined);
        if (orgUnitNumber) {
            setTimeout(() => {
                storeSelectorStateManager?.setSelectedStoreLocationId(orgUnitNumber);
            }, this.timeout);
        }
    };

    /**
     * Get the pushpin option.
     * @param isSelectedLocation - Is selected location.
     * @param index - Index.
     * @param pushpinOptions - PushpinOptions.
     * @returns - The pushpin options.
     */
    private readonly _getPushpinOptions = (isSelectedLocation: boolean, index: number, pushpinOptions?: IPushpinOptionsData) => {
        const text = pushpinOptions?.showIndex ? (index + 1).toString() : undefined;

        const size = pushpinOptions?.size || 1;
        const color = isSelectedLocation && pushpinOptions?.selectionColor
            ? pushpinOptions.selectionColor
            : pushpinOptions?.color;
        const icon = this._getSvgIcon(size, color, text);

        return {
            // Fallback if icon doesn't render properly
            color: isSelectedLocation ? pushpinOptions?.selectionColor : pushpinOptions?.color,
            icon
        };
    };

    private readonly _getSvgIcon = (size: number, color?: string, text?: string) => {
        const baseValue: number = 32;
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${baseValue * size}" height="${baseValue * size}" viewBox="0 0 365 560">
                    <path fill="${color}" d="M182.9,551.7c0,0.1,0.2,0.3,0.2,0.3S358.3,283,358.3,194.6c0-130.1-88.8-186.7-175.4-186.9 C96.3,7.9,7.5,64.5,7.5,194.6c0,88.4,175.3,357.4,175.3,357.4S182.9,551.7,182.9,551.7z" />
                    ${text ? `<text x="185" y="280" style="font-size:220px;fill:#ffffff;" text-anchor="middle">${text}</text>` : ''}
                </svg>`;
    };

    /**
     * Load the Azure Maps CSS dynamically.
     */
    private _loadCss(): void {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://atlas.microsoft.com/sdk/javascript/mapcontrol/3/atlas.min.css';
        link.type = 'text/css';
        document.head.appendChild(link);
    }
}

export default AzureMap;
