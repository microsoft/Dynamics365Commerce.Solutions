/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/// <reference types="bingmaps" />

/* eslint-disable no-duplicate-imports */
import * as Msdyn365 from '@msdyn365-commerce/core';
import { DeliveryOption, ItemAvailability, OrgUnitLocation, StoreHours } from '@msdyn365-commerce/retail-proxy';
import { IStoreInfo, IStoreSelectionStateContext } from '@msdyn365-commerce-modules/bopis-utilities';
import {
    ArrayExtensions,
    getFullAvailableInventoryNearby,
    GetFullAvailableInventoryNearbyInput,
    getOrgUnitLocationsByArea,
    GetOrgUnitLocationsByAreaInput,
    IFullOrgUnitAvailability
} from '@msdyn365-commerce-modules/retail-actions';
import {
    getTelemetryObject,
    IModuleProps,
    INodeProps,
    isMobile,
    ITelemetryContent,
    Modal,
    ModalBody,
    ModalFooter,
    ModalHeader,
    NodeTag,
    VariantType
} from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import {
    StoreSelectorEmptyMessage,
    StoreSelectorFoundLocationsMessage,
    StoreSelectorLocationLines,
    StoreSelectorSearchForm,
    StoreSelectorTermsOfService,
    StoreSelectorWaiting
} from './components';
import { ISelectedStoreProps, ISelectedStoreViewProps, SelectedStoreComponent } from './components/selected-store/selected-store';
import { buildStoreHours, IHoursDisplayInfo, secondsToTime } from './components/custom-store-selector-location-line-item/date-time-helpers';
import { ICustomStoreSelectorData } from './custom-store-selector.data';
import {
    ICustomStoreSelectorProps,
    ICustomStoreSelectorResources,
    mode as modeEnum,
    searchRadiusUnit as SearchRadiusUnit,
    style as styleEnum
} from './custom-store-selector.props.autogenerated';
import { ISuggestion } from './interfaces';

/**
 * StoreSelector State Interface.
 */
export interface IStoreSelectorState {
    isSearchInProgress: boolean;
    searchTerm?: string;
    isSeeAllStoreValue: boolean;
    isLocationDisabled?: boolean;
    filteredPickupMode?: string;
}

/**
 * StoreSelector View Props Interface.
 */
export interface IStoreSelectorViewProps extends ICustomStoreSelectorProps<ICustomStoreSelectorData> {
    state: IStoreSelectorState;

    // Containers:
    ModuleProps: IModuleProps;
    BodyContainerProps: INodeProps;
    FooterContainerProps: INodeProps;
    HeaderContainerProps: INodeProps;
    HeaderProps?: React.ReactNode;

    // Components
    locationsMessage?: React.ReactNode;
    search?: React.ReactNode;
    spinner?: React.ReactNode;
    locationsList?: React.ReactNode;
    selectedLocation?: ISelectedStoreViewProps;
    noLocationsMessage?: React.ReactNode;
    terms?: React.ReactNode;
    headerText?: React.ReactNode;
    sortLocations?: IFullOrgUnitAvailability[];
    locationListProps?: IStoreSelectorLocationLineItemProps[];
    bodyWrapperProps?: INodeProps;
    storeResultContainerProps?: INodeProps;
    mapContainerProps?: INodeProps;
    maps?: React.ReactNode;
    isMobileView?: boolean;
    storeDetailsModal?: INodeProps;

    callbacks: {
        closeDialog(): Promise<void>;
        searchTermChanged(searchTerm: string): Promise<void>;
        performSearch(searchTerm: string): Promise<void>;
        selectedLocation(location: OrgUnitLocation | undefined): Promise<void>;
        getAndUpdateUserLocation(): Promise<void>;
        onSuggestionSelected(result: Microsoft.Maps.ISuggestionResult): Promise<void>;
        setPreferredStore(storeId: string | undefined): Promise<void>;
        removePreferredStore(): Promise<void>;
        setSelectedStore(storeId: string | undefined): Promise<void>;
        setOrgUnitStoreInformation(location: OrgUnitLocation | undefined): Promise<void>;
    };
}

/**
 * StoreSelectorLocation Line Resources Interface.
 */
export interface IStoreSelectorLocationLineItemResources {
    contactInfoHeader: string;
    storeHoursHeader: string;
    availabilityInfoHeader: string;
    closedText: string;
    outOfStock: string;
    inStock: string;
    currentLocation: string;
    selectLocation: string;
    selectLocationAriaLabelFormat: string;
    setAsPreferredStoreText: string;
    setAsPreferredStoreTextAriaLabel: string;
    preferredStoreText: string;
    preferredStoreAriaLabel: string;

    days: {
        monday: string;
        tuesday: string;
        wednesday: string;
        thursday: string;
        friday: string;
        saturday: string;
        sunday: string;
        mondayFull: string;
        tuesdayFull: string;
        wednesdayFull: string;
        thursdayFull: string;
        fridayFull: string;
        saturdayFull: string;
        sundayFull: string;
    };
}

/**
 * ILocationHours Interface.
 */
export interface ILocationHours {
    openFrom?: string;
    openTo?: string;
}

/**
 * StoreSelectorLocation Line Item Props Interface.
 */
export interface IStoreSelectorLocationLineItemProps {
    location: OrgUnitLocation;
    storeHours?: StoreHours;
    storeHoursList?: IHoursDisplayInfo[];

    hideStockStatus?: boolean;
    isInStock?: boolean;
    isCurrentLocation?: boolean;

    resources: IStoreSelectorLocationLineItemResources;
    stockStatusLabel?: string;
    storeLocatorView?: boolean;
    isPreferredStoreEnabled?: boolean;
    index: string;
    preferredStoreLocationId: string | null;
    storePickUpOptionList?: DeliveryOption[];
    productPickUpOptionList?: DeliveryOption[];
    selectedStoreLocationId?: string;
    locationOpen?: ILocationHours;

    /**
     * The telemetry content.
     */
    telemetryContent?: ITelemetryContent;
    preferredDistanceUnit: string;
    isLocationDisabled?: boolean;
    handlers: {
        onSelected(location: OrgUnitLocation, deliveryMode?: string): void;
        onSetAsPreferredStore(locationId: string | undefined): void;
        onRemovePreferredStore(): void;
        closeStoreDetailsModal(): Promise<void>;
    };
    onClick: (locationId: string | undefined) => void;
}

/**
 *
 * Pick Up In Store module.
 * @extends React.Component<IPickUpInStoreProps<IPickUpInStoreData>>}
 */
@observer
class StoreSelector extends React.Component<ICustomStoreSelectorProps<ICustomStoreSelectorData>, IStoreSelectorState> {
    private readonly telemetryContent: ITelemetryContent;

    private storeCounter: number;

    private isPreferredStoreEnabled?: boolean;

    public constructor(props: ICustomStoreSelectorProps<ICustomStoreSelectorData>) {
        super(props);
        // eslint-disable-next-line react/no-unused-state -- State is used in the view.
        this.state = { isSearchInProgress: true, searchTerm: '', isSeeAllStoreValue: false, filteredPickupMode: undefined };
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        this.storeCounter = 0;
    }

    public async componentDidMount(): Promise<void> {
        const {
            context: {
                actionContext: {
                    requestContext: { channel }
                }
            }
        } = this.props;

        // Adding Timeout to make sure it loads the data based upon the preferred store.
        setTimeout(() => {
            this._getAndUpdateStoreLocation();
        }, 0);

        reaction(
            () => this.props.data.storeSelectorStateManager.result?.isDialogOpen,
            async () => {
                const context = this.props.data.storeSelectorStateManager.result?.context;
                if (context?.id === this.props.id) {
                    this._getAndUpdateStoreLocation();
                }
            }
        );

        reaction(
            () => this.props.data.storeSelectorStateManager.result?.context?.id,
            async () => {
                const context = this.props.data.storeSelectorStateManager.result?.context;
                if (!context || context.id === this.props.id) {
                    await this._searchTermChanged('');
                    this._getAndUpdateStoreLocation();
                }
            }
        );

        if (this.props.data.storeSelectorStateManager.result?.loadMapApi) {
            await this.props.data.storeSelectorStateManager.result.loadMapApi({
                key: channel?.BingMapsEnabled ? channel.BingMapsApiKey : '',
                lang: this.props.context.actionContext.requestContext.locale,
                market: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode
            });
        }

        reaction(
            () => this.props.data.storeSelectorStateManager.result?.loadMapApi,
            () => {
                this.props.data.storeSelectorStateManager.result?.loadMapApi({
                    key: channel?.BingMapsEnabled ? channel.BingMapsApiKey : '',
                    lang: this.props.context.actionContext.requestContext.locale,
                    market: this.props.context.actionContext.requestContext.channel?.ChannelCountryRegionISOCode
                });
            }
        );

        reaction(
            () => this.props.data.availabilitiesWithHours.result,
            async () => {
                if (this.props.data.storeSelectorStateManager.result?.isDialogOpen) {
                    const storeLocationList = this.props.data.availabilitiesWithHours.result;
                    if (storeLocationList) {
                        await this._setOrgUnitStoreInformation(storeLocationList);
                    }
                }
            }
        );
    }

    public shouldComponentUpdate(): boolean {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;
        const context = storeSelectorStateManager ? storeSelectorStateManager.context : undefined;
        if (context && context.id === this.props.id) {
            return true;
        }
        return false;
    }

    // eslint-disable-next-line complexity -- disabling the complexity for this method for now as its causing lot of other warnings
    public render(): JSX.Element {
        const {
            config: {
                termsOfServiceLink,
                className,
                heading,
                mode,
                style,
                setAsPreferredStore: shouldSetAsPreferredStore,
                showAllStores: shouldShowAllStores,
                lookupRadius,
                enablePickupFilterToShowStore: hasEnablePickupFilterToShowStore,
                searchRadiusUnit,
                autoSuggestionEnabled: isAutoSuggestionsEnabled,
                autoSuggestOptions
            },
            context: {
                telemetry,
                app: { config: appConfig },
                actionContext: {
                    requestContext: { channel, cookies, locale }
                }
            },
            slots: { maps: mapSlot },
            resources,
            data: {
                availabilitiesWithHours: { result: availabilitiesWithHours },
                storeSelectorStateManager: { result: storeSelectorStateManager },
                storeLocations: { result: storeLocations }
            }
        } = this.props;

        this.storeCounter = 0;
        const isMobileDevice = isMobile({ variant: VariantType.Viewport, context: this.props.context.request }) === 'xs';
        const context = storeSelectorStateManager ? storeSelectorStateManager.context : undefined;
        const isDialogOpen: boolean = storeSelectorStateManager
            ? storeSelectorStateManager.isDialogOpen && context?.id === this.props.id
            : false;
        const styleDefault = style !== undefined ? style : styleEnum.dialog;
        const modeDefault = mode !== undefined ? mode : modeEnum.pickupInStore;
        const isInlineView = styleDefault === styleEnum.inline;
        const isLocatorView = modeDefault === modeEnum.findStores;
        const shouldHideInventory = isLocatorView;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;
        const preferredStore: IStoreInfo | undefined = storeSelectorStateManager?.preferredStore;
        const shouldDisplayList = storeSelectorStateManager?.listMapViewState?.displayList;
        this.isPreferredStoreEnabled = shouldSetAsPreferredStore && cookies?.isConsentGiven();
        const canShowLocationView =
            context && (context.showMapViewLink === undefined || context.showMapViewLink) && storeSelectorStateManager?.isMapModuleLoaded;

        const storeSelectorActions = {
            async toggleListMapViewState(): Promise<void> {
                await storeSelectorStateManager?.toggleListMapViewState();
            }
        };

        const configHeading = heading ? heading : isLocatorView ? resources.storeLocatorHeaderText : resources.storeSelectorHeaderText;
        const preferredDistanceUnit =
            searchRadiusUnit === SearchRadiusUnit.kilometers ? resources.kilometersShortText : resources.milesShortText;
        const preferredLocationId = preferredStore?.StoreId ? preferredStore.StoreId : '';
        let storeLocationList: IFullOrgUnitAvailability[] | undefined = shouldHideInventory ? storeLocations : availabilitiesWithHours;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment -- Reading value from app config.
        const isEnableOutofStock: boolean = appConfig?.enableStockCheck || false;
        const alreadySelectedLocation = context ? context.alreadySelectedLocation : undefined;
        const productPickUpOptionList = storeSelectorStateManager?.context?.deliveryOptions?.DeliveryOptions;
        if (this.state.filteredPickupMode && storeLocationList) {
            storeLocationList = this.onFilterLocations(storeLocationList, this.state.filteredPickupMode);
        }

        let sortLocation = null;
        if (storeLocationList) {
            sortLocation = this._sortStores(storeLocationList, this.isPreferredStoreEnabled, preferredLocationId);
        }

        const locationListProps = this._getStoreLocationListProps(
            isEnableOutofStock,
            isLocatorView,
            preferredLocationId,
            this.isPreferredStoreEnabled,
            selectedStoreLocationId,
            sortLocation ?? null,
            preferredDistanceUnit,
            alreadySelectedLocation,
            productPickUpOptionList
        );

        const hasMapSlot = ArrayExtensions.hasElements(mapSlot);
        const dialogClassName = hasMapSlot ? 'ms-store-select__map' : '';
        const viewProps: IStoreSelectorViewProps = {
            ...(this.props as ICustomStoreSelectorProps<ICustomStoreSelectorData>),
            state: this.state,
            maps: hasMapSlot ? mapSlot[0] : undefined,

            ModuleProps: {
                tag: isInlineView ? ('div' as NodeTag) : Modal,
                moduleProps: this.props,
                className: classname(
                    `ms-store-${isInlineView ? 'locate' : 'select'}`,
                    className,
                    dialogClassName,
                    isInlineView ? '' : 'msc-modal-input-required'
                ),
                autoFocus: true,
                fade: true,
                isOpen: isDialogOpen,
                'aria-label': configHeading,
                onClosed: this._closeDialog,
                horizontalPosition: 'center',
                verticalPosition: 'center',
                toggle: this._closeDialog
            },
            isMobileView: isMobileDevice,
            HeaderContainerProps: {
                tag: isInlineView ? ('div' as NodeTag) : ModalHeader,
                className: `ms-store-select__${isInlineView ? 'header' : 'modal-header'}`,
                toggle: this._closeDialog
            },
            HeaderProps: configHeading && (
                <Msdyn365.Text
                    className='msc-modal__title'
                    {...configHeading}
                    tag='h2'
                    text={configHeading}
                    editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
                />
            ),
            FooterContainerProps: {
                tag: isInlineView ? ('div' as NodeTag) : ModalFooter,
                className: `ms-store-select__${isInlineView ? 'footer' : 'modal-footer'} ${!shouldDisplayList ? 'map-only-view' : ''}`
            },
            BodyContainerProps: {
                tag: isInlineView ? ('div' as NodeTag) : ModalBody,
                className: `ms-store-select__${isInlineView ? 'body' : 'modal-body'}`
            },
            bodyWrapperProps: {
                tag: 'div' as NodeTag,
                className: 'ms-store-select__body_wrapper'
            },
            storeResultContainerProps: {
                tag: 'div' as NodeTag,
                className: 'ms-store-select__store_container'
            },
            mapContainerProps: {
                tag: 'div' as NodeTag,
                className: 'ms-store-select__map_container'
            },
            storeDetailsModal: {
                tag: 'div' as NodeTag,
                className: `ms-store-select__map__selected_store__modal ${
                    selectedStoreLocationId && isDialogOpen && !shouldDisplayList ? 'show' : 'hide'
                }`
            },
            locationsMessage: !this.state.isLocationDisabled && (
                <StoreSelectorFoundLocationsMessage
                    resources={resources}
                    locations={storeLocationList}
                    searchRadius={lookupRadius || 50}
                    preferredDistanceUnit={preferredDistanceUnit}
                    isSeeAllStore={this.state.isSeeAllStoreValue}
                />
            ),
            selectedLocation: this.renderSelectedStore(
                shouldHideInventory,
                preferredDistanceUnit,
                preferredStore,
                this.isPreferredStoreEnabled,
                isEnableOutofStock,
                productPickUpOptionList,
                shouldDisplayList
            ),
            search: (
                <StoreSelectorSearchForm
                    value={this.state.searchTerm || ''}
                    resources={resources}
                    performSearch={this._performSearch}
                    searchTermChanged={this._searchTermChanged}
                    showAllStores={shouldShowAllStores}
                    id={this.props.id}
                    onShowAllStores={this.onShowAllStoresHandler}
                    onToggleListMapViewState={storeSelectorActions.toggleListMapViewState}
                    displayList={shouldDisplayList}
                    locatorView={canShowLocationView}
                    productPickUpDeliveryOptions={storeSelectorStateManager?.context?.deliveryOptions?.DeliveryOptions}
                    telemetryContent={this.telemetryContent}
                    filterPickupModeSelected={this.onFilteredPickupMode}
                    hasEnabledPickupFilterToShowStore={hasEnablePickupFilterToShowStore}
                    filteredPickupMode={this.state.filteredPickupMode}
                    onSuggestionsSelected={this._onSuggestionSelected}
                    autoSuggestionEnabled={isAutoSuggestionsEnabled}
                    autoSuggestOptions={autoSuggestOptions}
                    telemetry={telemetry}
                    channel={channel}
                    locale={locale}
                    isMapAPILoaded={storeSelectorStateManager?.isMapApiLoaded}
                />
            ),
            spinner: <StoreSelectorWaiting />,
            locationsList: ArrayExtensions.hasElements(storeLocationList) ? (
                <StoreSelectorLocationLines
                    locations={storeLocationList}
                    resources={resources}
                    preferredDistanceUnit={preferredDistanceUnit}
                    alreadySelectedLocation={context ? context.alreadySelectedLocation : undefined}
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- Reading config value.
                    outOfStockThreshold={appConfig.outOfStockThreshold || 0}
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- Reading config value.
                    enableOutOfStockCheck={appConfig.enableStockCheck || false}
                    onLocationSelected={this._onOrgUnitLocationSelected}
                    storeLocatorView={isLocatorView}
                    selectedStoreLocationId={selectedStoreLocationId}
                    onClick={this._setSelectedStore}
                    preferredStoreLocationId={preferredStore?.StoreId ? preferredStore.StoreId : ''}
                    onSetAsPreferredStore={this._setPreferredStore}
                    onRemovePreferredStore={this._removePreferredStore}
                    isPreferredStoreEnabled={this.isPreferredStoreEnabled}
                    displayList={shouldDisplayList}
                    telemetryContent={this.telemetryContent}
                    isLocationDisabled={this.state.isLocationDisabled}
                    productPickUpDeliveryOptions={storeSelectorStateManager?.context?.deliveryOptions?.DeliveryOptions}
                    filteredPickupMode={this.state.filteredPickupMode}
                    shouldShowIndex={hasMapSlot}
                />
            ) : (
                undefined
            ),
            noLocationsMessage: <StoreSelectorEmptyMessage resources={resources} />,
            terms: (
                <StoreSelectorTermsOfService
                    link={termsOfServiceLink}
                    onTextChange={this.handleLinkTextChange}
                    requestContext={this.props.context.request}
                />
            ),

            // Not being used in current context, we can use it here to pass more props.
            headerText: (
                <span>{heading ? heading : isLocatorView ? resources.storeLocatorHeaderText : resources.storeSelectorHeaderText}</span>
            ),
            sortLocations: sortLocation,
            locationListProps,
            callbacks: {
                searchTermChanged: this._searchTermChanged,
                performSearch: this._performSearch,
                closeDialog: this._closeDialog,
                selectedLocation: this._onOrgUnitLocationSelected,
                getAndUpdateUserLocation: async () => {
                    this._getAndUpdateStoreLocation();
                    return Promise.resolve();
                },
                onSuggestionSelected: this._onOrgUnitLocationSelected,
                setPreferredStore: this._setPreferredStore,
                removePreferredStore: this._removePreferredStore,
                setSelectedStore: this._setSelectedStore,
                setOrgUnitStoreInformation: this._setOrgUnitStoreInformation
            }
        } as IStoreSelectorViewProps;

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    /**
     * Render the selected store for the mobile devices.
     * @param shouldHideInventory -- Hide Inventory.
     * @param preferredDistanceUnit -- Preferred Distance Unit.
     * @param preferredStore -- Preferred Store.
     * @param isPreferredStoreEnabled -- Is Preferred Store Enabled.
     * @param hasEnabledOutOfStockCheck -- Stock check is enabled or not.
     * @param productPickUpOptionList -- Product pickup option list.
     * @param shouldDisplayList - Should Display list.
     * @returns -- Returns the view props.
     */
    public renderSelectedStore = (
        shouldHideInventory: boolean,
        preferredDistanceUnit: string,
        preferredStore: IStoreInfo | undefined,
        isPreferredStoreEnabled: boolean | undefined,
        hasEnabledOutOfStockCheck: boolean,
        productPickUpOptionList?: DeliveryOption[],
        shouldDisplayList?: boolean
    ): ISelectedStoreViewProps | undefined => {
        const {
            resources,
            data: {
                availabilitiesWithHours: { result: availabilitiesWithHours },
                storeSelectorStateManager: { result: storeSelectorStateManager },
                storeLocations: { result: storeLocations }
            }
        } = this.props;

        const context = storeSelectorStateManager ? storeSelectorStateManager.context : undefined;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;
        const selectedStore = (shouldHideInventory ? storeLocations : availabilitiesWithHours)?.find(
            store => store.OrgUnitAvailability?.OrgUnitLocation?.OrgUnitNumber === selectedStoreLocationId
        );
        const orgUnitLocation = selectedStore?.OrgUnitAvailability?.OrgUnitLocation;
        const selectedStoreResources = this._mapResources(resources);

        if (!shouldDisplayList && selectedStore) {
            const selectedProps: ISelectedStoreProps = {
                shouldHideStockStatus: shouldHideInventory,
                isCurrentLocation: this._isCurrentLocation(orgUnitLocation, context?.alreadySelectedLocation),
                isInStock: this._isProductInStock(hasEnabledOutOfStockCheck, selectedStore.OrgUnitAvailability?.ItemAvailabilities),
                selectedStore,
                resources: selectedStoreResources,
                stockStatusLabel: this._stockInventoryLabel(selectedStore),
                preferredStoreLocationId: preferredStore?.StoreId ? preferredStore.StoreId : '',
                isPreferredStoreEnabled,
                isLocationDisabled: this.state.isLocationDisabled,
                telemetryContent: this.telemetryContent,
                storePickUpOptionList: selectedStore.OrgUnitPickUpDeliveryModes?.DeliveryOptions,
                productPickUpOptionList,
                preferredDistanceUnit,
                handlers: {
                    onSelected: this._onOrgUnitLocationSelected,
                    onSetAsPreferredStore: this._setPreferredStore,
                    onRemovePreferredStore: this._removePreferredStore,
                    closeStoreDetailsModal: this._closeStoreDetailModal
                }
            };

            return SelectedStoreComponent(selectedProps);
        }

        return undefined;
    };

    /**
     * Method to be called on link text change.
     * @param event -Content Edit Event.
     */
    public handleLinkTextChange = (event: Msdyn365.ContentEditableEvent): void => {
        if (this.props.config.termsOfServiceLink) {
            this.props.config.termsOfServiceLink.linkText = event.target.value;
        }
    };

    /**
     * Method to be called on heading change.
     * @param event -Content Edit Event.
     */
    public handleHeadingChange = (event: Msdyn365.ContentEditableEvent): void => {
        this.props.config.heading = event.target.value;
    };

    /**
     * Show all stores handler function.
     */
    private readonly onShowAllStoresHandler = () => {
        this._getAndUpdateStoreLocation(true);
        this.setState({ filteredPickupMode: undefined });
    };

    /**
     * Method to be called for filtered the store location based on the filter selected by the user.
     * @param stores -All the stores from the API.
     * @param filteredPickupMode -Filter selected by the user.
     * @returns -Filtered stores.
     */
    private readonly onFilterLocations = (stores: IFullOrgUnitAvailability[], filteredPickupMode: string) => {
        return stores.filter(location => {
            return location.OrgUnitPickUpDeliveryModes?.DeliveryOptions?.some(deliveryOption => {
                return deliveryOption.Code === filteredPickupMode;
            });
        });
    };

    /**
     * Filter Store by pickup mode.
     * @param deliveryCode -Delivery Code.
     */
    private readonly onFilteredPickupMode = (deliveryCode: string) => {
        this.setState({ filteredPickupMode: deliveryCode });
    };

    /**
     * Method will sort all stores.
     * @param stores -Stores List.
     * @param isPreferredStoreEnabled -Module config value.
     * @param preferredStoreLocationId -Store Id.
     * @returns List of Stores.
     */
    // eslint-disable-next-line class-methods-use-this -- No need of introducing new variable.
    private _sortStores(
        stores: IFullOrgUnitAvailability[],
        isPreferredStoreEnabled: boolean | undefined,
        preferredStoreLocationId: string
    ): IFullOrgUnitAvailability[] {
        const isPreferredStore = (value: IFullOrgUnitAvailability) =>
            isPreferredStoreEnabled &&
            preferredStoreLocationId &&
            value.OrgUnitAvailability?.OrgUnitLocation?.OrgUnitNumber === preferredStoreLocationId;

        return [...stores.filter(isPreferredStore), ...stores.filter(store => !isPreferredStore(store))];
    }

    /**
     * Method will list of store selector location line.
     * @param hasEnabledOutOfStockCheck -Stores List.
     * @param isStoreLocatorView -Module config value.
     * @param preferredStoreLocationId -Store Id.
     * @param isPreferredStoreEnabled -Stores List.
     * @param selectedStoreLocationId -Module config value.
     * @param stores -Store Id.
     * @param preferredDistanceUnit -Module config value.
     * @param alreadySelectedLocation -Already Selected Location.
     * @param productPickUpOptionList -Product supported Pickup Modes List.
     * @returns List of StoreSelectorLocation Line.
     */
    private _getStoreLocationListProps(
        hasEnabledOutOfStockCheck: boolean,
        isStoreLocatorView: boolean,
        preferredStoreLocationId: string,
        isPreferredStoreEnabled: boolean | undefined,
        selectedStoreLocationId: string | undefined,
        stores: IFullOrgUnitAvailability[] | null,
        preferredDistanceUnit?: string | undefined,
        alreadySelectedLocation?: OrgUnitLocation,
        productPickUpOptionList?: DeliveryOption[]
    ): IStoreSelectorLocationLineItemProps[] {
        const storeList: IStoreSelectorLocationLineItemProps[] = [];
        if (ArrayExtensions.hasElements(stores)) {
            stores.map((store, index: number) => {
                const storeLineProps = this._createStoreLocationList(
                    store,
                    index,
                    hasEnabledOutOfStockCheck,
                    isStoreLocatorView,
                    preferredStoreLocationId,
                    isPreferredStoreEnabled,
                    selectedStoreLocationId,
                    preferredDistanceUnit,
                    alreadySelectedLocation,
                    productPickUpOptionList
                );
                if (storeLineProps) {
                    storeList.push(storeLineProps);
                }
            });
        }
        return storeList;
    }

    /**
     * On Selecting Location Suggestion.
     * @param result - Map Suggestions List.
     */
    private readonly _onSuggestionSelected = async (result: ISuggestion): Promise<void> => {
        const context = this.props.data.storeSelectorStateManager.result?.context;
        if (context && context.id === this.props.id) {
            await this._searchTermChanged(result.formattedSuggestion);
            await this._performSearch(result.formattedSuggestion, result.latitude, result.longitude);
        }
    };

    /**
     * On Selecting Preferred Store.
     * @param storeId - Store Id.
     */
    private readonly _setPreferredStore = async (storeId: string | undefined): Promise<void> => {
        if (!storeId) {
            return;
        }

        const {
            context: {
                actionContext: {
                    requestContext: { cookies }
                }
            },
            config: { mode },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager },
                storeLocations: { result: storeLocations },
                availabilitiesWithHours: { result: availabilitiesWithHours }
            }
        } = this.props;

        if (!storeSelectorStateManager) {
            return;
        }
        const modeDefault = mode !== undefined ? mode : modeEnum.pickupInStore;

        let stores: IFullOrgUnitAvailability[];
        if (modeDefault === modeEnum.findStores && storeLocations) {
            stores = storeLocations;
        } else {
            stores = availabilitiesWithHours!;
        }

        const preferredStore = stores.find(store => store.OrgUnitAvailability?.OrgUnitLocation?.OrgUnitNumber === storeId);

        await storeSelectorStateManager.setPreferredStoreLocation(
            storeId,
            preferredStore?.OrgUnitAvailability?.OrgUnitLocation?.OrgUnitName,
            cookies.isConsentGiven(),
            preferredStore?.OrgUnitAvailability?.OrgUnitLocation?.Latitude,
            preferredStore?.OrgUnitAvailability?.OrgUnitLocation?.Longitude
        );
    };

    /**
     * On Removing Preferred Store.
     */
    private readonly _removePreferredStore = async (): Promise<void> => {
        const {
            context: {
                actionContext: {
                    requestContext: { cookies }
                }
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!storeSelectorStateManager) {
            return;
        }

        await storeSelectorStateManager.clearPreferredStore(cookies.isConsentGiven());
    };

    /**
     * Method called to close the store details modal that comes up on clicking the pushpin.
     * @returns Void promise.
     */
    private readonly _closeStoreDetailModal = async (): Promise<void> => {
        const storeSelectorStateManager = this.props.data.storeSelectorStateManager.result;
        await storeSelectorStateManager?.setSelectedStoreLocationId(undefined);
    };

    /**
     * On Selecting Store for pickup.
     * @param storeId - Store Id.
     */
    private readonly _setSelectedStore = async (storeId: string | undefined): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!storeSelectorStateManager) {
            return;
        }

        await storeSelectorStateManager.setSelectedStoreLocationId(storeId);
    };

    /**
     * Method to be called on search.
     * @param searchTerm - Search string.
     */
    private readonly _performSearch = async (searchTerm: string, latitude?: number, longitude?: number): Promise<void> => {
        const {
            context: { actionContext },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!searchTerm || !storeSelectorStateManager) {
            return;
        }

        // eslint-disable-next-line react/no-unused-state -- State is used in the view.
        this.setState({ isSearchInProgress: true, isSeeAllStoreValue: false });

        const location =
            latitude && longitude
                ? { latitude, longitude }
                : await storeSelectorStateManager.geoLocate(searchTerm.trim() || '0', actionContext);

        await this._updateLocations(location?.latitude, location?.longitude);
        // eslint-disable-next-line react/no-unused-state -- State is used in the view.
        this.setState({ isSearchInProgress: false });
    };

    /**
     * Method to be called on search term changed.
     * @param searchTerm - Search string.
     */
    private readonly _searchTermChanged = async (searchTerm: string): Promise<void> => {
        this.setState({ searchTerm });
    };

    /**
     * Method to be called updating the store location.
     * @param shouldShowAllStores - Flag to show all stores.
     */
    private readonly _getAndUpdateStoreLocation = (shouldShowAllStores?: boolean): void => {
        const {
            config: { style },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        const styleDefault = style !== undefined ? style : styleEnum.dialog;

        if (styleDefault !== styleEnum.inline && (!storeSelectorStateManager || !storeSelectorStateManager.isDialogOpen)) {
            // Store selector dialog isn't open yet, so don't try and update anything
            return;
        }

        // eslint-disable-next-line react/no-unused-state -- State is used in the view.
        this.setState({ isSearchInProgress: true, isSeeAllStoreValue: false });

        if (navigator?.geolocation) {
            navigator.geolocation.getCurrentPosition(
                async position => {
                    // eslint-disable-next-line react/no-unused-state -- This state is used in the views.
                    this.setState({ isLocationDisabled: false, isSearchInProgress: true });
                    if (shouldShowAllStores) {
                        this.setState({ isSeeAllStoreValue: true });
                        await this._searchTermChanged('');
                        await this._updateLocations(position.coords.latitude, position.coords.longitude, 0);
                    } else {
                        await this._updateLocations(position.coords.latitude, position.coords.longitude);
                    }

                    // eslint-disable-next-line react/no-unused-state -- State is used in the view.
                    this.setState({ isSearchInProgress: false });
                },
                async error => {
                    // If the location setting is turned off
                    if (error.PERMISSION_DENIED) {
                        this.setState({ isLocationDisabled: true, isSeeAllStoreValue: true });
                        await this._searchTermChanged('');
                        await this._updateLocations(0, 0, 0);
                    }

                    // eslint-disable-next-line react/no-unused-state -- State is used in the view.
                    this.setState({ isSearchInProgress: false });
                },
                { timeout: 5000 }
            );
        } else {
            // eslint-disable-next-line react/no-unused-state -- State is used in the view.
            this.setState({ isSearchInProgress: false });
        }
    };

    /**
     * Method to be called closing the store selector dialog.
     * @returns Void promise.
     */
    private readonly _closeDialog = async (): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        this.setState({ searchTerm: '' });

        if (storeSelectorStateManager) {
            storeSelectorStateManager.context?.parentElementRef?.current?.focus();
            return storeSelectorStateManager.closeDialog();
        }
    };

    /**
     * Method to set store info.
     * @param orgUnitStoreInformation - Store Info Object.
     * @returns Void promise.
     */
    private readonly _setOrgUnitStoreInformation = async (orgUnitStoreInformation: IFullOrgUnitAvailability[]): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            },
            config: { style },
            telemetry
        } = this.props;

        if (!storeSelectorStateManager) {
            return;
        }

        const context = storeSelectorStateManager.context;
        const moduleId: string = context?.id ? context.id : this.props.id;
        const styleDefault = style !== undefined ? style : styleEnum.dialog;
        let input: IStoreSelectionStateContext = {
            /**
             * On Location selected.
             * @returns - Returns promise.
             */
            onLocationSelected: async () => {
                // TO-DO handle event for when location in selected
                return Promise.resolve();
            }
        };

        if (storeSelectorStateManager.context) {
            input = storeSelectorStateManager.context;
        }

        const preferredStore: IStoreInfo | undefined = storeSelectorStateManager.preferredStore;
        const preferredLocationId = preferredStore?.StoreId ? preferredStore.StoreId : '';
        const storeLocationList = this._sortStores(orgUnitStoreInformation, this.isPreferredStoreEnabled, preferredLocationId);

        input = {
            ...input,
            id: moduleId,
            showMapViewLink: context?.showMapViewLink,
            parentElementRef: context?.parentElementRef,
            isDialog: styleDefault === styleEnum.dialog,
            orgUnitStoreInformation: storeLocationList,
            product: context?.product
        };

        await storeSelectorStateManager.setOrgUnitStoreInformation(input).catch((error: Error) => {
            if (telemetry) {
                telemetry.error(error.message);
                telemetry.debug('Unable to Update store location state');
            }
        });
    };

    /**
     * Method to update user location.
     * @param latitude - User location.
     * @param longitude - User location.
     * @param radius - Search Criteria Radius.
     * @returns Void promise.
     */
    private readonly _updateLocations = async (latitude?: number, longitude?: number, radius?: number): Promise<void> => {
        const {
            config: { mode, lookupRadius, style, searchRadiusUnit },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        const styleDefault = style !== undefined ? style : styleEnum.dialog;
        const calRadius = radius || radius === 0 ? radius : lookupRadius || 50;
        const distanceUnitValue = searchRadiusUnit === SearchRadiusUnit.kilometers ? 1 : 0;
        const modeDefault = mode !== undefined ? mode : modeEnum.pickupInStore;
        const preferredStore: IStoreInfo | undefined = storeSelectorStateManager?.preferredStore;
        let localLatitude = this.state.searchTerm || !preferredStore?.Latitude ? latitude : preferredStore.Latitude;
        let long = this.state.searchTerm || !preferredStore?.Longitude ? longitude : preferredStore.Longitude;
        if (styleDefault === styleEnum.inline) {
            const lastInlineStoreLocation = storeSelectorStateManager?.lastInlineShownStoreInfo;
            if (lastInlineStoreLocation && !this.state.searchTerm) {
                localLatitude = lastInlineStoreLocation.Latitude ? lastInlineStoreLocation.Latitude : localLatitude;
                long = lastInlineStoreLocation.Longitude ? lastInlineStoreLocation.Longitude : long;
            }
            await storeSelectorStateManager?.setLastInlineStoreInfo(localLatitude, long);
        }

        if (modeDefault === modeEnum.findStores) {
            await this.getOrgUnitLocationByArea(calRadius, distanceUnitValue, localLatitude, long);
            return;
        }

        await this.getFullAvailableInventoryNearby(calRadius, distanceUnitValue, localLatitude, long);
    };

    /**
     * Get org unit location by area.
     * @param calRadius - Radius.
     * @param distanceUnitValue - Distance unit value.
     * @param latitude - Latitude.
     * @param longitude - Longitude.
     * @returns - Returns a void promise.
     */
    private readonly getOrgUnitLocationByArea = async (
        calRadius: number,
        distanceUnitValue: number,
        latitude?: number,
        longitude?: number
    ): Promise<void> => {
        const {
            context: { actionContext }
        } = this.props;
        const orgUnitLocationsInput = new GetOrgUnitLocationsByAreaInput(
            latitude,
            longitude,
            calRadius,
            distanceUnitValue,
            this.state.isLocationDisabled
        );

        const orgUnitLocations = await getOrgUnitLocationsByArea(orgUnitLocationsInput, actionContext);
        if (orgUnitLocations) {
            await this._setOrgUnitStoreInformation(orgUnitLocations);
            await this._setSelectedStore(undefined);
        }
    };

    /**
     * Get full available inventory nearby.
     * @param calRadius - Radius.
     * @param distanceUnitValue - Distance unit value.
     * @param latitude - Latitude.
     * @param longitude - Longitude.
     * @returns - Returns a void promise.
     */
    private readonly getFullAvailableInventoryNearby = async (
        calRadius: number,
        distanceUnitValue: number,
        latitude?: number,
        longitude?: number
    ): Promise<void> => {
        const {
            telemetry,
            context: { actionContext },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!storeSelectorStateManager || !storeSelectorStateManager.context) {
            // Store selector dialog isn't open yet, so don't try and update anything
            return;
        }

        if (!storeSelectorStateManager.context.product) {
            // TODO: Use alternative search method here to not make inventory check
            return;
        }

        const input = new GetFullAvailableInventoryNearbyInput(
            storeSelectorStateManager.context.product.RecordId,
            latitude ?? 0,
            longitude ?? 0,
            calRadius,
            distanceUnitValue,
            this.state.isLocationDisabled
        );

        await getFullAvailableInventoryNearby(input, actionContext).catch(error => {
            telemetry.warning(error);
            telemetry.error(error.message);
            telemetry.debug('Unable to get full available inventory near by');
        });
    };

    /**
     * Method to called on store selected.
     * @param location - Store Info.
     * @param deliveryMode - Pickup mode.
     * @returns Void promise.
     */
    private readonly _onOrgUnitLocationSelected = async (location: OrgUnitLocation | undefined, deliveryMode?: string): Promise<void> => {
        const {
            telemetry,
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (storeSelectorStateManager) {
            if (location && storeSelectorStateManager.context) {
                // Want to eat exceptions here so that the dialog still closes even if the onLocationSelected call goes wrong
                await storeSelectorStateManager.context.onLocationSelected(location, deliveryMode).catch(error => {
                    telemetry.warning(error);
                    telemetry.error(error.message);
                    telemetry.debug('Unable to get on org unit location selected');
                });
            }

            await storeSelectorStateManager.closeDialog();
        }
    };

    /**
     * Method will list of store selector location line.
     * @param store -Store Info.
     * @param index - List index.
     * @param hasEnabledOutOfStockCheck -Stores List.
     * @param isStoreLocatorView -Module config value.
     * @param preferredStoreLocationId -Store Id.
     * @param isPreferredStoreEnabled -Stores List.
     * @param selectedStoreLocationId -Module config value.
     * @param preferredDistanceUnit -Module config value.
     * @param alreadySelectedLocation -Already Selected Location.
     * @param productPickUpOptionList -Product supported Pickup Modes List.
     * @returns StoreSelectorLocation Line Prop.
     */
    private _createStoreLocationList(
        store: IFullOrgUnitAvailability,
        index: number,
        hasEnabledOutOfStockCheck: boolean,
        isStoreLocatorView: boolean,
        preferredStoreLocationId: string,
        isPreferredStoreEnabled: boolean | undefined,
        selectedStoreLocationId: string | undefined,
        preferredDistanceUnit?: string | undefined,
        alreadySelectedLocation?: OrgUnitLocation,
        productPickUpOptionList?: DeliveryOption[]
    ): IStoreSelectorLocationLineItemProps | undefined {
        const orgUnitLocation = store.OrgUnitAvailability?.OrgUnitLocation;
        const selectedStoreLocation = selectedStoreLocationId;
        const deliveryOptions = store.OrgUnitPickUpDeliveryModes;
        const lineResources = this._mapResources(this.props.resources);
        const storeOpenFrom: string | undefined = secondsToTime(orgUnitLocation?.OpenFrom);
        const storeOpenTo: string | undefined = secondsToTime(orgUnitLocation?.OpenTo);
        const storeHours = store.StoreHours;

        if (orgUnitLocation) {
            ++this.storeCounter;
            return {
                location: orgUnitLocation,
                selectedStoreLocationId: selectedStoreLocation,
                storeHours,
                resources: lineResources,
                preferredDistanceUnit: preferredDistanceUnit!,
                isCurrentLocation: this._isCurrentLocation(orgUnitLocation, alreadySelectedLocation),
                hideStockStatus: !hasEnabledOutOfStockCheck,
                isInStock: this._isProductInStock(hasEnabledOutOfStockCheck, store.OrgUnitAvailability?.ItemAvailabilities),
                stockStatusLabel: this._stockInventoryLabel(store),
                storeLocatorView: isStoreLocatorView,
                index: this.storeCounter.toString(),
                preferredStoreLocationId,
                isPreferredStoreEnabled,
                telemetryContent: this.telemetryContent,
                isLocationDisabled: this.state.isLocationDisabled,
                storePickUpOptionList: deliveryOptions?.DeliveryOptions,
                productPickUpOptionList,
                locationOpen: { openFrom: storeOpenFrom, openTo: storeOpenTo },
                storeHoursList: storeHours?.RegularStoreHours ? buildStoreHours(storeHours.RegularStoreHours, lineResources) : [],
                onClick: this._setSelectedStore,
                handlers: {
                    onSelected: this._onOrgUnitLocationSelected,
                    onSetAsPreferredStore: this._setPreferredStore,
                    onRemovePreferredStore: this._removePreferredStore,
                    closeStoreDetailsModal: this._closeStoreDetailModal
                }
            };
        }
        return undefined;
    }

    /**
     * Method to map resources with Location Item.
     * @param resources - List of strings for module.
     * @returns Resources for StoreSelector location line.
     */
    private readonly _mapResources = (resources: ICustomStoreSelectorResources): IStoreSelectorLocationLineItemResources => {
        return {
            contactInfoHeader: resources.contactText,
            storeHoursHeader: resources.timeText,
            availabilityInfoHeader: resources.availabilityText,

            closedText: resources.storeHoursClosedText,
            outOfStock: resources.outOfStockText,
            inStock: resources.inStockText,

            currentLocation: resources.selectedStoreLocationText,
            selectLocation: resources.selectStoreText,
            selectLocationAriaLabelFormat: resources.selectStoreAriaFormatText,
            setAsPreferredStoreText: resources.setAsPreferredStoreText,
            setAsPreferredStoreTextAriaLabel: resources.setAsPreferredStoreTextAriaLabel,
            preferredStoreText: resources.preferredStoreText,
            preferredStoreAriaLabel: resources.preferredStoreAriaLabel,

            days: {
                monday: resources.storeHoursMondayText,
                tuesday: resources.storeHoursTuesdayText,
                wednesday: resources.storeHoursWednesdayText,
                thursday: resources.storeHoursThursdayText,
                friday: resources.storeHoursFridayText,
                saturday: resources.storeHoursSaturdayText,
                sunday: resources.storeHoursSundayText,
                mondayFull: resources.storeHoursMondayFullText,
                tuesdayFull: resources.storeHoursTuesdayFullText,
                wednesdayFull: resources.storeHoursWednesdayFullText,
                thursdayFull: resources.storeHoursThursdayFullText,
                fridayFull: resources.storeHoursFridayFullText,
                saturdayFull: resources.storeHoursSaturdayFullText,
                sundayFull: resources.storeHoursSundayFullText
            }
        };
    };

    private readonly _isCurrentLocation = (location: OrgUnitLocation | undefined, selectedLocation?: OrgUnitLocation): boolean =>
        (selectedLocation && location && selectedLocation.OrgUnitNumber === location.OrgUnitNumber) || false;

    /**
     * Method to get stock.
     * @param hasEnableOutOfStockCheck - Config to check for stock check enabled.
     * @param itemAvailabilities - Item quantity availability.
     * @returns Boolean value for item stock.
     */
    private readonly _isProductInStock = (
        hasEnableOutOfStockCheck: boolean,
        itemAvailabilities: ItemAvailability[] | undefined
    ): boolean => {
        if (!hasEnableOutOfStockCheck) {
            return true;
        }
        const quantityCount = 0;
        if (ArrayExtensions.hasElements(itemAvailabilities)) {
            return itemAvailabilities[0].AvailableQuantity ? itemAvailabilities[0].AvailableQuantity > quantityCount : false;
        }

        return false;
    };

    /**
     * Method to get stocklevel label.
     * @param isInStock - Stock available in store.
     * @returns Label for stock status.
     */
    private readonly _stockInventoryLabel = (isInStock: IFullOrgUnitAvailability | undefined): string | undefined => {
        if (isInStock?.ProductInventoryInformation && ArrayExtensions.hasElements(isInStock.ProductInventoryInformation)) {
            for (let index = 0; index < isInStock.ProductInventoryInformation.length; index++) {
                if (
                    isInStock.OrgUnitAvailability?.OrgUnitLocation?.InventoryLocationId ===
                    isInStock.ProductInventoryInformation[index].InventLocationId
                ) {
                    return isInStock.ProductInventoryInformation[index].StockLevelLabel;
                }
            }
        }

        return undefined;
    };
}

export default StoreSelector;
